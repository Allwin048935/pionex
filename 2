import requests
import time
import hmac
import hashlib
from urllib.parse import urlencode
import json
import pandas as pd
import matplotlib.pyplot as plt
import mplfinance as mpf
from io import BytesIO
import asyncio
from telegram import Bot, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import Application, CallbackQueryHandler
import ta
import pytz
import config  # Import config.py for API credentials

# API setup
BASE_URL = "https://api.pionex.com"
API_KEY = config.API_KEY
SECRET_KEY = config.SECRET_KEY
TELEGRAM_TOKEN = config.TELEGRAM_TOKEN_RSI
CHAT_ID = config.CHAT_ID

# Telegram setup
telegram_bot = Bot(token=TELEGRAM_TOKEN)

# Global storage
last_alert_messages = {}
pending_orders = {}

# Function to generate HMAC SHA256 signature
def generate_signature(method, path, params, body=None):
    timestamp = str(int(time.time() * 1000))
    query_params = params.copy()
    query_params['timestamp'] = timestamp
    sorted_params = urlencode(sorted(query_params.items()))
    path_url = f"{path}?{sorted_params}"
    string_to_sign = f"{method}{path_url}"
    if body:
        string_to_sign += json.dumps(body, separators=(',', ':'))
    signature = hmac.new(
        SECRET_KEY.encode('utf-8'),
        string_to_sign.encode('utf-8'),
        hashlib.sha256
    ).hexdigest()
    return signature, timestamp

# Function to make authenticated API requests
def api_request(method, endpoint, params=None, body=None):
    if params is None:
        params = {}
    signature, timestamp = generate_signature(method, endpoint, params, body)
    params['timestamp'] = timestamp
    url = f"{BASE_URL}{endpoint}"
    headers = {
        "PIONEX-KEY": API_KEY,
        "PIONEX-SIGNATURE": signature,
        "Content-Type": "application/json"
    }
    try:
        if method == "GET":
            response = requests.get(url, headers=headers, params=params)
        elif method == "POST":
            response = requests.post(url, headers=headers, params=params, data=json.dumps(body, separators=(',', ':')))
        elif method == "DELETE":
            response = requests.delete(url, headers=headers, params=params)
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        print(f"API request failed: {e}")
        return None

# Function to get all USDT pairs
def get_usdt_pairs():
    endpoint = "/api/v1/common/symbols"
    data = api_request("GET", endpoint)
    if data and 'data' in data and 'symbols' in data['data']:
        usdt_pairs = [s['symbol'] for s in data['data']['symbols'] if s['symbol'].endswith('_USDT') and s['enable']]
        return usdt_pairs
    print("Error: Failed to fetch USDT pairs")
    return []

# Function to get symbol info with error handling
def get_symbol_info(symbol):
    endpoint = "/api/v1/common/symbols"
    params = {"symbols": symbol}
    data = api_request("GET", endpoint, params)
    if data and 'data' in data and 'symbols' in data['data'] and data['data']['symbols']:
        return data['data']['symbols'][0]
    print(f"Error: No symbol info returned for {symbol} - Response: {data}")
    return None

# Function to get account balance
def get_balance(currency="USDT"):
    endpoint = "/api/v1/account/balances"
    data = api_request("GET", endpoint)
    if data and 'data' in data and 'balances' in data['data']:
        for balance in data['data']['balances']:
            if balance['coin'] == currency:
                return float(balance['free'])
    print(f"Error: Failed to fetch balance for {currency}")
    return 0.0

# Function to get current price
def get_price(symbol):
    endpoint = "/api/v1/market/depth"
    params = {"symbol": symbol}
    data = api_request("GET", endpoint, params)
    if data and 'data' in data and 'bids' in data['data'] and data['data']['bids']:
        bid = float(data['data']['bids'][0][0])
        ask = float(data['data']['asks'][0][0])
        return (bid + ask) / 2
    print(f"Error: Failed to fetch price data for {symbol}")
    return None

# Simulate historical OHLCV data with more volatility
def get_historical_data(symbol, interval_minutes=1, limit=50):
    data = []
    base_price = get_price(symbol)
    if not base_price:
        return pd.DataFrame()
    for i in range(limit):
        price = base_price * (1 + 0.005 * (i % 2 - 0.5))
        timestamp = int(time.time() * 1000) - (i * interval_minutes * 60 * 1000)
        open_price = price * (1 - 0.002)
        high_price = price * (1 + 0.003)
        low_price = price * (1 - 0.004)
        close_price = price
        volume = 100
        data.append([timestamp, open_price, high_price, low_price, close_price, volume])
        time.sleep(0.1)
    df = pd.DataFrame(data, columns=['timestamp', 'open', 'high', 'low', 'close', 'volume'])
    df['timestamp'] = pd.to_datetime(df['timestamp'], unit='ms')
    df.set_index('timestamp', inplace=True)
    df.columns = ['Open', 'High', 'Low', 'Close', 'Volume']
    return df

# MACD calculation
def calculate_macd(df):
    macd = ta.trend.MACD(df['Close'])
    df['macd'] = macd.macd()
    df['signal'] = macd.macd_signal()
    df['histogram'] = macd.macd_diff()

# Check MACD crossover
def check_macd_signal_crossover(df, symbol):
    if len(df) < 3:
        return False, False
    # Force a crossover for testing on BTC_USDT (remove after testing)
    if symbol == "BTC_USDT" and not hasattr(check_macd_signal_crossover, 'tested'):
        check_macd_signal_crossover.tested = True
        return True, False
    macd_prev = df['macd'].iloc[-2]
    macd_curr = df['macd'].iloc[-1]
    signal_prev = df['signal'].iloc[-2]
    signal_curr = df['signal'].iloc[-1]
    cross_over = macd_prev < signal_prev and macd_curr > signal_curr
    cross_under = macd_prev > signal_prev and macd_curr < signal_curr
    return cross_over, cross_under

# Fibonacci levels
def calculate_fibonacci_levels(df):
    high = df['High'].max()
    low = df['Low'].min()
    diff = high - low
    levels = {
        '0.0%': high,
        '23.6%': high - (0.236 * diff),
        '38.2%': high - (0.382 * diff),
        '50.0%': high - (0.5 * diff),
        '61.8%': high - (0.618 * diff),
        '100.0%': low
    }
    return levels

# Plot candlestick chart with MACD and Fibonacci
def plot_candles(df, symbol, title):
    calculate_macd(df)
    fib_levels = calculate_fibonacci_levels(df)

    macd_colors = ['green' if h > 0 else 'red' for h in df['histogram']]
    mc = mpf.make_marketcolors(up='#2fc71e', down='#ed2f1a', inherit=True)
    s = mpf.make_mpf_style(base_mpl_style=['bmh', 'dark_background'], marketcolors=mc, y_on_right=True)

    add_plots = [
        mpf.make_addplot(df['macd'], panel=1, color='blue', width=1.5, ylabel="MACD"),
        mpf.make_addplot(df['signal'], panel=1, color='orange', width=1.5),
        mpf.make_addplot(df['histogram'], type='bar', color=macd_colors, panel=1)
    ]

    for level, price in fib_levels.items():
        add_plots.append(
            mpf.make_addplot(
                [price] * len(df),
                color='yellow',
                linestyle='--',
                alpha=0.5,
                label=f'Fib {level}'
            )
        )

    fig, axlist = mpf.plot(
        df[['Open', 'High', 'Low', 'Close']],
        figratio=(10, 6),
        type="candle",
        style=s,
        tight_layout=True,
        datetime_format='%H:%M',
        ylabel="Price ($)",
        addplot=add_plots,
        returnfig=True
    )

    axlist[0].legend(loc='upper left', fontsize=8)
    axlist[0].set_title(f"{symbol} - {title}", fontsize=25, style='italic', fontfamily='sans-serif')

    buf = BytesIO()
    plt.savefig(buf, format='png', bbox_inches='tight')
    buf.seek(0)
    plt.close(fig)
    return buf

# Function to send Telegram message with chart and Buy button (inspired by reference)
async def send_telegram_message(symbol, message, image_buffer=None):
    try:
        if image_buffer:
            keyboard = [[InlineKeyboardButton("Buy", callback_data=f"buy_{symbol}")]]
            reply_markup = InlineKeyboardMarkup(keyboard)
            await telegram_bot.send_photo(chat_id=CHAT_ID, photo=image_buffer, caption=message, reply_markup=reply_markup)
            print(f"Sent Telegram message and image for {symbol} with Buy option")
        else:
            await telegram_bot.send_message(chat_id=CHAT_ID, text=message)
            print(f"Sent Telegram message for {symbol}")
    except Exception as e:
        print(f"Failed to send Telegram message for {symbol}: {e}")

# Function to place a limit order
def place_limit_order(symbol, side, quantity, price, precision):
    endpoint = "/api/v1/trade/order"
    params = {}
    body = {
        "symbol": symbol,
        "side": side.upper(),
        "type": "LIMIT",
        "size": f"{quantity:.{precision}f}",
        "price": str(price),
        "IOC": False
    }
    response = api_request("POST", endpoint, params, body)
    if response and 'data' in response and response['result']:
        return response['data']
    else:
        print(f"Order placement failed: {response}")
        return None

# Function to place a market sell order
def place_market_sell_order(symbol, quantity, precision):
    endpoint = "/api/v1/trade/order"
    params = {}
    body = {
        "symbol": symbol,
        "side": "SELL",
        "type": "MARKET",
        "size": f"{quantity:.{precision}f}"
    }
    response = api_request("POST", endpoint, params, body)
    if response and 'data' in response and response['result']:
        return response['data']
    else:
        print(f"Market sell order failed: {response}")
        return None

# Function to cancel an order
def cancel_order(symbol, order_id):
    endpoint = "/api/v1/trade/order"
    params = {"symbol": symbol, "orderId": order_id}
    response = api_request("DELETE", endpoint, params)
    if response and 'result' in response and response['result']:
        print(f"Canceled order {order_id} for {symbol}")
        return True
    else:
        print(f"Failed to cancel order {order_id} for {symbol}: {response}")
        return False

# Handle Telegram callback (Buy button)
async def handle_buy_callback(update, context):
    query = update.callback_query
    await query.answer()
    symbol = query.data.split("_")[1]
    target_usdt = 15.0

    symbol_info = get_symbol_info(symbol)
    if not symbol_info:
        await telegram_bot.send_message(chat_id=CHAT_ID, text=f"Error: Invalid symbol info for {symbol}")
        return

    min_amount = float(symbol_info['minAmount'])
    min_trade_size = float(symbol_info['minTradeSize'])
    base_precision = int(symbol_info['basePrecision'])

    price = get_price(symbol)
    if not price:
        await telegram_bot.send_message(chat_id=CHAT_ID, text=f"Error: Could not fetch price for {symbol}")
        return

    quantity = target_usdt / price
    if quantity < min_trade_size:
        quantity = min_trade_size

    order_amount = price * quantity
    if order_amount < min_amount:
        await telegram_bot.send_message(chat_id=CHAT_ID, text=f"{symbol}: Order amount ${order_amount:.2f} below minimum ${min_amount}")
        return

    usdt_balance = get_balance("USDT")
    if usdt_balance < order_amount:
        await telegram_bot.send_message(chat_id=CHAT_ID, text=f"{symbol}: Insufficient USDT (${usdt_balance:.2f} < ${order_amount:.2f})")
        return

    # Place buy order
    buy_result = place_limit_order(symbol, "BUY", quantity, price, base_precision)
    if buy_result:
        order_id = buy_result['orderId']
        print(f"{symbol}: Buy order placed: Order ID {order_id}")
        last_alert_messages[symbol] = "buy"
        await telegram_bot.send_message(chat_id=CHAT_ID, text=f"{symbol}: Buy order placed: Order ID {order_id}")

        # Place auto sell order at 1.01x price
        sell_price = price * 1.01
        sell_result = place_limit_order(symbol, "SELL", quantity, sell_price, base_precision)
        if sell_result:
            sell_order_id = sell_result['orderId']
            pending_orders[symbol] = sell_order_id
            print(f"{symbol}: Auto sell order placed at ${sell_price:.2f}: Order ID {sell_order_id}")
            await telegram_bot.send_message(chat_id=CHAT_ID, text=f"{symbol}: Auto sell order placed at ${sell_price:.2f}: Order ID {sell_order_id}")
        else:
            await telegram_bot.send_message(chat_id=CHAT_ID, text=f"{symbol}: Failed to place auto sell order")
    else:
        await telegram_bot.send_message(chat_id=CHAT_ID, text=f"{symbol}: Buy order failed")

# Trading bot logic for all USDT pairs
async def trading_bot():
    target_usdt = 15.0

    # Get all USDT pairs
    usdt_pairs = get_usdt_pairs()
    if not usdt_pairs:
        print("No USDT pairs found. Stopping bot.")
        return
    print(f"Monitoring {len(usdt_pairs)} USDT pairs: {usdt_pairs[:5]}...")

    # Get symbol info for all pairs, filtering out invalid ones
    symbol_info_dict = {}
    valid_usdt_pairs = []
    for symbol in usdt_pairs[:5]:  # Limit to 5 pairs for testing
        info = get_symbol_info(symbol)
        if info:
            symbol_info_dict[symbol] = info
            valid_usdt_pairs.append(symbol)
        else:
            print(f"Skipping {symbol} due to invalid symbol info")

    print(f"Valid USDT pairs to monitor: {len(valid_usdt_pairs)}")

    print("Starting Pionex trading bot...")
    while True:
        try:
            for symbol in valid_usdt_pairs:
                symbol_info = symbol_info_dict.get(symbol)
                if not symbol_info:
                    continue

                min_amount = float(symbol_info['minAmount'])
                min_trade_size = float(symbol_info['minTradeSize'])
                base_precision = int(symbol_info['basePrecision'])

                # Fetch historical data
                historical_data = get_historical_data(symbol, interval_minutes=1, limit=50)
                if historical_data.empty:
                    print(f"{symbol}: No historical data available")
                    continue

                price = get_price(symbol)
                if price is None:
                    continue

                quantity = target_usdt / price
                if quantity < min_trade_size:
                    quantity = min_trade_size

                order_amount = price * quantity
                if order_amount < min_amount:
                    print(f"{symbol}: Order amount ${order_amount:.2f} below minimum ${min_amount}. Skipping.")
                    continue

                # MACD strategy
                calculate_macd(historical_data)
                cross_over, cross_under = check_macd_signal_crossover(historical_data, symbol)
                holding = last_alert_messages.get(symbol) == "buy"

                if cross_over and not holding:
                    message = f"#Long #{symbol} - MACD Cross Over\nPrice: ${price:.2f}"
                    image_buffer = plot_candles(historical_data, symbol, "MACD Cross Over")
                    await send_telegram_message(symbol, message, image_buffer)

                elif cross_under and holding:
                    if symbol in pending_orders:
                        order_id = pending_orders[symbol]
                        if cancel_order(symbol, order_id):
                            del pending_orders[symbol]

                    print(f"{symbol}: MACD Cross Under! Selling {quantity:.8f} at market price")
                    sell_result = place_market_sell_order(symbol, quantity, base_precision)
                    if sell_result:
                        print(f"{symbol}: Market sell order placed: Order ID {sell_result['orderId']}")
                        last_alert_messages[symbol] = "sold"
                        await telegram_bot.send_message(chat_id=CHAT_ID, text=f"{symbol}: Market sell order placed: Order ID {sell_result['orderId']}")
                    else:
                        await telegram_bot.send_message(chat_id=CHAT_ID, text=f"{symbol}: Market sell order failed")

                else:
                    print(f"{symbol}: Current price: ${price} - No action (Holding: {holding})")

            await asyncio.sleep(10)
        except Exception as e:
            print(f"Error in bot loop: {e}")
            await asyncio.sleep(10)

# Main function to run bot and Telegram handler
async def main():
    application = Application.builder().token(TELEGRAM_TOKEN).job_queue_timezone(pytz.UTC).build()
    application.add_handler(CallbackQueryHandler(handle_buy_callback, pattern='^buy_'))

    # Start the trading bot
    asyncio.create_task(trading_bot())

    # Start the Telegram application
    await application.initialize()
    await application.start()
    await application.updater.start_polling()
    await asyncio.Event().wait()  # Keep the bot running

if __name__ == "__main__":
    asyncio.run(main())
