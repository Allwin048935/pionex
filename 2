import requests
import time
import hmac
import hashlib
from urllib.parse import urlencode
import json
import pandas as pd
import matplotlib.pyplot as plt
import mplfinance as mpf
from io import BytesIO
import asyncio
import nest_asyncio
from telegram import Bot, InlineKeyboardButton, InlineKeyboardMarkup, Update
from telegram.ext import Updater, CallbackQueryHandler, CallbackContext
import ta
import config
import logging
import warnings
import sys
import threading

warnings.filterwarnings("ignore", category=UserWarning)

logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s',
    handlers=[logging.StreamHandler()]
)
logger = logging.getLogger(__name__)

logger.info("Script loaded")
nest_asyncio.apply()
logger.info("Nest asyncio applied")

BASE_URL = "https://api.pionex.com"
try:
    API_KEY = config.API_KEY
    SECRET_KEY = config.SECRET_KEY
    TELEGRAM_TOKEN = config.TELEGRAM_TOKEN_RSI
    CHAT_ID = config.CHAT_ID
    logger.info(f"Config: API_KEY={API_KEY[:4]}..., TELEGRAM_TOKEN={TELEGRAM_TOKEN[:4]}..., CHAT_ID={CHAT_ID}")
except AttributeError as e:
    logger.error(f"Config loading failed: {e}")
    sys.exit(1)

logger.info("Initializing Telegram bot...")
try:
    telegram_bot = Bot(token=TELEGRAM_TOKEN)
    logger.info("Telegram bot initialized")
except Exception as e:
    logger.error(f"Telegram bot init failed: {e}")
    sys.exit(1)

last_alert_messages = {}
pending_orders = {}

def generate_signature(method, path, params, body=None):
    timestamp = str(int(time.time() * 1000))
    query_params = params.copy()
    query_params['timestamp'] = timestamp
    sorted_params = urlencode(sorted(query_params.items()))
    path_url = f"{path}?{sorted_params}"
    string_to_sign = f"{method}{path_url}"
    if body:
        string_to_sign += json.dumps(body, separators=(',', ':'))
    signature = hmac.new(SECRET_KEY.encode('utf-8'), string_to_sign.encode('utf-8'), hashlib.sha256).hexdigest()
    return signature, timestamp

def api_request(method, endpoint, params=None, body=None):
    if params is None:
        params = {}
    signature, timestamp = generate_signature(method, endpoint, params, body)
    params['timestamp'] = timestamp
    url = f"{BASE_URL}{endpoint}"
    headers = {"PIONEX-KEY": API_KEY, "PIONEX-SIGNATURE": signature, "Content-Type": "application/json"}
    try:
        if method == "GET":
            response = requests.get(url, headers=headers, params=params)
        elif method == "POST":
            response = requests.post(url, headers=headers, params=params, data=json.dumps(body, separators=(',', ':')))
        elif method == "DELETE":
            response = requests.delete(url, headers=headers, params=params)
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        logger.error(f"API request failed: {e}")
        return None

def get_usdt_pairs():
    endpoint = "/api/v1/common/symbols"
    data = api_request("GET", endpoint)
    if data and 'data' in data and 'symbols' in data['data']:
        usdt_pairs = [s['symbol'] for s in data['data']['symbols'] if s['symbol'].endswith('_USDT') and s['enable']]
        return usdt_pairs
    logger.error("Failed to fetch USDT pairs")
    return []

def get_symbol_info(symbol):
    endpoint = "/api/v1/common/symbols"
    params = {"symbols": symbol}
    data = api_request("GET", endpoint, params)
    if data and 'data' in data and 'symbols' in data['data'] and data['data']['symbols']:
        return data['data']['symbols'][0]
    logger.error(f"No symbol info returned for {symbol} - Response: {data}")
    return None

def get_balance(currency="USDT"):
    endpoint = "/api/v1/account/balances"
    data = api_request("GET", endpoint)
    if data and 'data' in data and 'balances' in data['data']:
        for balance in data['data']['balances']:
            if balance['coin'] == currency:
                return float(balance['free'])
    logger.error(f"Failed to fetch balance for {currency}")
    return 0.0

def get_price(symbol):
    endpoint = "/api/v1/market/depth"
    params = {"symbol": symbol}
    data = api_request("GET", endpoint, params)
    if data and 'data' in data and 'bids' in data['data'] and data['data']['bids']:
        bid = float(data['data']['bids'][0][0])
        ask = float(data['data']['asks'][0][0])
        return (bid + ask) / 2
    logger.error(f"Failed to fetch price data for {symbol}")
    return None

def get_historical_data(symbol, interval="1m", limit=50):
    endpoint = "/api/v1/market/klines"
    params = {
        "symbol": symbol,
        "interval": interval,
        "limit": limit
    }
    data = api_request("GET", endpoint, params)
    if data and 'data' in data and 'klines' in data['data']:
        klines = data['data']['klines']
        df = pd.DataFrame(klines, columns=['timestamp', 'open', 'high', 'low', 'close', 'volume', 'closeTime', 'quoteVolume', 'trades', 'takerBuyBase', 'takerBuyQuote', 'ignore'])
        df = df[['timestamp', 'open', 'high', 'low', 'close', 'volume']]
        df['timestamp'] = pd.to_datetime(df['timestamp'], unit='ms')
        df.set_index('timestamp', inplace=True)
        df = df.astype(float)
        df.columns = ['Open', 'High', 'Low', 'Close', 'Volume']
        return df
    logger.error(f"Failed to fetch historical data for {symbol}: {data}")
    return pd.DataFrame()

def calculate_macd(df):
    macd = ta.trend.MACD(df['Close'])
    df['macd'] = macd.macd()
    df['signal'] = macd.macd_signal()
    df['histogram'] = macd.macd_diff()

def check_macd_signal_crossover(df, symbol):
    if len(df) < 3:
        return False, False
    if symbol == "BTC_USDT" and not hasattr(check_macd_signal_crossover, 'tested'):
        check_macd_signal_crossover.tested = True
        return True, False
    macd_prev = df['macd'].iloc[-2]
    macd_curr = df['macd'].iloc[-1]
    signal_prev = df['signal'].iloc[-2]
    signal_curr = df['signal'].iloc[-1]
    cross_over = macd_prev < signal_prev and macd_curr > signal_curr
    cross_under = macd_prev > signal_prev and macd_curr < signal_curr
    return cross_over, cross_under

def calculate_fibonacci_levels(df):
    high = df['High'].max()
    low = df['Low'].min()
    diff = high - low
    levels = {'0.0%': high, '23.6%': high - (0.236 * diff), '38.2%': high - (0.382 * diff), '50.0%': high - (0.5 * diff), '61.8%': high - (0.618 * diff), '100.0%': low}
    return levels

def plot_candles(df, symbol, title):
    calculate_macd(df)
    fib_levels = calculate_fibonacci_levels(df)
    macd_colors = ['green' if h > 0 else 'red' for h in df['histogram']]
    mc = mpf.make_marketcolors(up='#2fc71e', down='#ed2f1a', inherit=True)
    s = mpf.make_mpf_style(base_mpl_style=['bmh', 'dark_background'], marketcolors=mc, y_on_right=True)
    add_plots = [
        mpf.make_addplot(df['macd'], panel=1, color='blue', width=1.5, ylabel="MACD"),
        mpf.make_addplot(df['signal'], panel=1, color='orange', width=1.5),
        mpf.make_addplot(df['histogram'], type='bar', color=macd_colors, panel=1)
    ]
    for level, price in fib_levels.items():
        add_plots.append(mpf.make_addplot([price] * len(df), color='yellow', linestyle='--', alpha=0.5, label=f'Fib {level}'))
    fig, axlist = mpf.plot(df[['Open', 'High', 'Low', 'Close']], figratio=(10, 6), type="candle", style=s, tight_layout=True, datetime_format='%H:%M', ylabel="Price ($)", addplot=add_plots, returnfig=True)
    axlist[0].legend(loc='upper left', fontsize=8)
    axlist[0].set_title(f"{symbol} - {title}", fontsize=25, style='italic', fontfamily='sans-serif')
    buf = BytesIO()
    plt.savefig(buf, format='png', bbox_inches='tight')
    buf.seek(0)
    plt.close(fig)
    return buf

def send_telegram_message(symbol, message, image_buffer, close_price):
    unique_key = f"{symbol}_{message}_{close_price}"
    if last_alert_messages.get(symbol, "") != unique_key:
        keyboard = [[InlineKeyboardButton("Buy", callback_data=f"buy|{symbol}|{close_price}")]]
        reply_markup = InlineKeyboardMarkup(keyboard)
        telegram_bot.send_message(chat_id=CHAT_ID, text=message, reply_markup=reply_markup)
        telegram_bot.send_photo(chat_id=CHAT_ID, photo=image_buffer)
        logger.info(f"Sent Telegram message and image for {symbol}")
        last_alert_messages[symbol] = unique_key

def place_limit_order(symbol, side, quantity, price, precision):
    endpoint = "/api/v1/trade/order"
    params = {}
    body = {"symbol": symbol, "side": side.upper(), "type": "LIMIT", "size": f"{quantity:.{precision}f}", "price": str(price), "IOC": False}
    response = api_request("POST", endpoint, params, body)
    if response and 'data' in response and response['result']:
        return response['data']
    logger.error(f"Order placement failed: {response}")
    return None

def place_market_sell_order(symbol, quantity, precision):
    endpoint = "/api/v1/trade/order"
    params = {}
    body = {"symbol": symbol, "side": "SELL", "type": "MARKET", "size": f"{quantity:.{precision}f}"}
    response = api_request("POST", endpoint, params, body)
    if response and 'data' in response and response['result']:
        return response['data']
    logger.error(f"Market sell order failed: {response}")
    return None

def cancel_order(symbol, order_id):
    endpoint = "/api/v1/trade/order"
    params = {"symbol": symbol, "orderId": order_id}
    response = api_request("DELETE", endpoint, params)
    if response and 'result' in response and response['result']:
        logger.info(f"Canceled order {order_id} for {symbol}")
        return True
    logger.error(f"Failed to cancel order {order_id} for {symbol}: {response}")
    return False

def handle_telegram_callback(update: Update, context: CallbackContext):
    query = update.callback_query
    query.answer()
    data = query.data.split('|')
    if len(data) != 3:
        context.bot.send_message(chat_id=CHAT_ID, text="Invalid command format.")
        logger.error(f"Invalid callback data: {query.data}")
        return
    action, symbol, close_price = data[0], data[1], float(data[2])
    target_usdt = 15.0
    symbol_info = get_symbol_info(symbol)
    if not symbol_info:
        context.bot.send_message(chat_id=CHAT_ID, text=f"Error: Invalid symbol info for {symbol}")
        return
    min_amount = float(symbol_info['minAmount'])
    min_trade_size = float(symbol_info['minTradeSize'])
    base_precision = int(symbol_info['basePrecision'])
    price = close_price
    quantity = target_usdt / price
    if quantity < min_trade_size:
        quantity = min_trade_size
    order_amount = price * quantity
    if order_amount < min_amount:
        context.bot.send_message(chat_id=CHAT_ID, text=f"{symbol}: Order amount ${order_amount:.2f} below minimum ${min_amount}")
        logger.warning(f"{symbol}: Order amount ${order_amount:.2f} below minimum ${min_amount}")
        return
    usdt_balance = get_balance("USDT")
    if usdt_balance < order_amount:
        context.bot.send_message(chat_id=CHAT_ID, text=f"{symbol}: Insufficient USDT (${usdt_balance:.2f} < ${order_amount:.2f})")
        logger.warning(f"{symbol}: Insufficient USDT (${usdt_balance:.2f} < ${order_amount:.2f})")
        return
    if action == "buy":
        buy_result = place_limit_order(symbol, "BUY", quantity, price, base_precision)
        if buy_result:
            order_id = buy_result['orderId']
            logger.info(f"{symbol}: Buy order placed: Order ID {order_id}")
            last_alert_messages[symbol] = "buy"
            context.bot.send_message(chat_id=CHAT_ID, text=f"{symbol}: Buy order placed: Order ID {order_id}")
            sell_price = price * 1.01
            sell_result = place_limit_order(symbol, "SELL", quantity, sell_price, base_precision)
            if sell_result:
                sell_order_id = sell_result['orderId']
                pending_orders[symbol] = sell_order_id
                logger.info(f"{symbol}: Auto sell order placed at ${sell_price:.2f}: Order ID {sell_order_id}")
                context.bot.send_message(chat_id=CHAT_ID, text=f"{symbol}: Auto sell order placed at ${sell_price:.2f}: Order ID {sell_order_id}")
            else:
                context.bot.send_message(chat_id=CHAT_ID, text=f"{symbol}: Failed to place auto sell order")
        else:
            context.bot.send_message(chat_id=CHAT_ID, text=f"{symbol}: Buy order failed")

async def trading_bot():
    target_usdt = 15.0
    logger.info("Fetching USDT pairs...")
    usdt_pairs = get_usdt_pairs()
    if not usdt_pairs:
        logger.error("No USDT pairs found. Stopping bot.")
        return
    logger.info(f"Monitoring {len(usdt_pairs)} USDT pairs: {usdt_pairs[:5]}...")
    symbol_info_dict = {}
    valid_usdt_pairs = []
    for symbol in usdt_pairs[:5]:
        info = get_symbol_info(symbol)
        if info:
            symbol_info_dict[symbol] = info
            valid_usdt_pairs.append(symbol)
        else:
            logger.warning(f"Skipping {symbol} due to invalid symbol info")
    logger.info(f"Valid USDT pairs to monitor: {len(valid_usdt_pairs)}")
    logger.info("Starting Pionex trading bot loop...")
    while True:
        try:
            for symbol in valid_usdt_pairs:
                symbol_info = symbol_info_dict.get(symbol)
                if not symbol_info:
                    continue
                min_amount = float(symbol_info['minAmount'])
                min_trade_size = float(symbol_info['minTradeSize'])
                base_precision = int(symbol_info['basePrecision'])
                historical_data = get_historical_data(symbol)
                if historical_data.empty:
                    logger.warning(f"{symbol}: No historical data available")
                    continue
                price = get_price(symbol)
                if price is None:
                    continue
                quantity = target_usdt / price
                if quantity < min_trade_size:
                    quantity = min_trade_size
                order_amount = price * quantity
                if order_amount < min_amount:
                    logger.info(f"{symbol}: Order amount ${order_amount:.2f} below minimum ${min_amount}. Skipping.")
                    continue
                calculate_macd(historical_data)
                cross_over, cross_under = check_macd_signal_crossover(historical_data, symbol)
                holding = last_alert_messages.get(symbol) == "buy"
                if cross_over and not holding:
                    message = f"#Long #{symbol} - MACD Cross Over\nPrice: ${price:.2f}"
                    image_buffer = plot_candles(historical_data, symbol, "MACD Cross Over")
                    send_telegram_message(symbol, message, image_buffer, price)
                elif cross_under and holding:
                    if symbol in pending_orders:
                        order_id = pending_orders[symbol]
                        if cancel_order(symbol, order_id):
                            del pending_orders[symbol]
                    logger.info(f"{symbol}: MACD Cross Under! Selling {quantity:.8f} at market price")
                    sell_result = place_market_sell_order(symbol, quantity, base_precision)
                    if sell_result:
                        logger.info(f"{symbol}: Market sell order placed: Order ID {sell_result['orderId']}")
                        last_alert_messages[symbol] = "sold"
                        telegram_bot.send_message(chat_id=CHAT_ID, text=f"{symbol}: Market sell order placed: Order ID {sell_result['orderId']}")
                    else:
                        telegram_bot.send_message(chat_id=CHAT_ID, text=f"{symbol}: Market sell order failed")
                else:
                    logger.info(f"{symbol}: Current price: ${price} - No action (Holding: {holding})")
            await asyncio.sleep(10)
        except Exception as e:
            logger.error(f"Error in bot loop: {e}")
            await asyncio.sleep(10)

def run_trading_bot():
    logger.info("Starting trading bot in thread...")
    asyncio.run(trading_bot())

def main():
    logger.info("Starting main function...")
    try:
        updater = Updater(TELEGRAM_TOKEN, use_context=True)
        dp = updater.dispatcher
        dp.add_handler(CallbackQueryHandler(handle_telegram_callback, pattern='^buy\|'))
        trading_thread = threading.Thread(target=run_trading_bot, daemon=True)
        trading_thread.start()
        logger.info("Starting Telegram polling...")
        updater.start_polling()
        updater.idle()
    except Exception as e:
        logger.error(f"Main function crashed: {e}")
        raise

if __name__ == "__main__":
    logger.info("Script starting...")
    try:
        main()
    except Exception as e:
        logger.error(f"Script crashed: {e}")
