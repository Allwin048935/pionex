import requests
import time
import hmac
import hashlib
from urllib.parse import urlencode
import json
import pandas as pd
import matplotlib.pyplot as plt
import mplfinance as mpf
from io import BytesIO
import asyncio
import nest_asyncio
from telegram import Bot, InlineKeyboardButton, InlineKeyboardMarkup, Update
from telegram.ext import Updater, CallbackQueryHandler, CallbackContext
import ta
import config  # Import config.py for API credentials
import logging
import warnings

# Suppress all UserWarnings (broader scope)
warnings.filterwarnings("ignore", category=UserWarning)

# Setup logging with clear format
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s',
    handlers=[logging.StreamHandler()]
)
logger = logging.getLogger(__name__)

# Apply nest_asyncio
logger.info("Applying nest_asyncio...")
nest_asyncio.apply()

# API setup
BASE_URL = "https://api.pionex.com"
try:
    API_KEY = config.API_KEY
    SECRET_KEY = config.SECRET_KEY
    TELEGRAM_TOKEN = config.TELEGRAM_TOKEN_RSI
    CHAT_ID = config.CHAT_ID
    logger.info("Config loaded successfully")
except AttributeError as e:
    logger.error(f"Config loading failed: {e}")
    exit(1)

# Telegram setup
logger.info("Initializing Telegram bot...")
telegram_bot = Bot(token=TELEGRAM_TOKEN)

# Global storage
last_alert_messages = {}
pending_orders = {}

# Function to generate HMAC SHA256 signature
def generate_signature(method, path, params, body=None):
    timestamp = str(int(time.time() * 1000))
    query_params = params.copy()
    query_params['timestamp'] = timestamp
    sorted_params = urlencode(sorted(query_params.items()))
    path_url = f"{path}?{sorted_params}"
    string_to_sign = f"{method}{path_url}"
    if body:
        string_to_sign += json.dumps(body, separators=(',', ':'))
    signature = hmac.new(
        SECRET_KEY.encode('utf-8'),
        string_to_sign.encode('utf-8'),
        hashlib.sha256
    ).hexdigest()
    return signature, timestamp

# Function to make authenticated API requests
def api_request(method, endpoint, params=None, body=None):
    if params is None:
        params = {}
    signature, timestamp = generate_signature(method, endpoint, params, body)
    params['timestamp'] = timestamp
    url = f"{BASE_URL}{endpoint}"
    headers = {
        "PIONEX-KEY": API_KEY,
        "PIONEX-SIGNATURE": signature,
        "Content-Type": "application/json"
    }
    try:
        if method == "GET":
            response = requests.get(url, headers=headers, params=params)
        elif method == "POST":
            response = requests.post(url, headers=headers, params=params, data=json.dumps(body, separators=(',', ':')))
        elif method == "DELETE":
            response = requests.delete(url, headers=headers, params=params)
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        logger.error(f"API request failed: {e}")
        return None

# Function to get all USDT pairs
def get_usdt_pairs():
    endpoint = "/api/v1/common/symbols"
    data = api_request("GET", endpoint)
    if data and 'data' in data and 'symbols' in data['data']:
        usdt_pairs = [s['symbol'] for s in data['data']['symbols'] if s['symbol'].endswith('_USDT') and s['enable']]
        return usdt_pairs
    logger.error("Failed to fetch USDT pairs")
    return []

# Function to get symbol info with error handling
def get_symbol_info(symbol):
    endpoint = "/api/v1/common/symbols"
    params = {"symbols": symbol}
    data = api_request("GET", endpoint, params)
    if data and 'data' in data and 'symbols' in data['data'] and data['data']['symbols']:
        return data['data']['symbols'][0]
    logger.error(f"No symbol info returned for {symbol} - Response: {data}")
    return None

# Function to get account balance
def get_balance(currency="USDT"):
    endpoint = "/api/v1/account/balances"
    data = api_request("GET", endpoint)
    if data and 'data' in data and 'balances' in data['data']:
        for balance in data['data']['balances']:
            if balance['coin'] == currency:
                return float(balance['free'])
    logger.error(f"Failed to fetch balance for {currency}")
    return 0.0

# Function to get current price
def get_price(symbol):
    endpoint = "/api/v1/market/depth"
    params = {"symbol": symbol}
    data = api_request("GET", endpoint, params)
    if data and 'data' in data and 'bids' in data['data'] and data['data']['bids']:
        bid = float(data['data']['bids'][0][0])
        ask = float(data['data']['asks'][0][0])
        return (bid + ask) / 2
    logger.error(f"Failed to fetch price data for {symbol}")
    return None

# Simulate historical OHLCV data with more volatility
def get_historical_data(symbol, interval_minutes=1, limit=50):
    data = []
    base_price = get_price(symbol)
    if not base_price:
        return pd.DataFrame()
    for i in range(limit):
        price = base_price * (1 + 0.005 * (i % 2 - 0.5))
        timestamp = int(time.time() * 1000) - (i * interval_minutes * 60 * 1000)
        open_price = price * (1 - 0.002)
        high_price = price * (1 + 0.003)
        low_price = price * (1 - 0.004)
        close_price = price
        volume = 100
        data.append([timestamp, open_price, high_price, low_price, close_price, volume])
        time.sleep(0.1)
    df = pd.DataFrame(data, columns=['timestamp', 'open', 'high', 'low', 'close', 'volume'])
    df['timestamp'] = pd.to_datetime(df['timestamp'], unit='ms')
    df.set_index('timestamp', inplace=True)
    df.columns = ['Open', 'High', 'Low', 'Close', 'Volume']
    return df

# MACD calculation
def calculate_macd(df):
    macd = ta.trend.MACD(df['Close'])
    df['macd'] = macd.macd()
    df['signal'] = macd.macd_signal()
    df['histogram'] = macd.macd_diff()

# Check MACD crossover
def check_macd_signal_crossover(df, symbol):
    if len(df) < 3:
        return False, False
    if symbol == "BTC_USDT" and not hasattr(check_macd_signal_crossover, 'tested'):
        check_macd_signal_crossover.tested = True
        return True, False
    macd_prev = df['macd'].iloc[-2]
    macd_curr = df['macd'].iloc[-1]
    signal_prev = df['signal'].iloc[-2]
    signal_curr = df['signal'].iloc[-1]
    cross_over = macd_prev < signal_prev and macd_curr > signal_curr
    cross_under = macd_prev > signal_prev and macd_curr < signal_curr
    return cross_over, cross_under

# Fibonacci levels
def calculate_fibonacci_levels(df):
    high = df['High'].max()
    low = df['Low'].min()
    diff = high - low
    levels = {
        '0.0%': high,
        '23.6%': high - (0.236 * diff),
        '38.2%': high - (0.382 * diff),
        '50.0%': high - (0.5 * diff),
        '61.8%': high - (0.618 * diff),
        '100.0%': low
    }
    return levels

# Plot candlestick chart with MACD and Fibonacci
def plot_candles(df, symbol, title):
    calculate_macd(df)
    fib_levels = calculate_fibonacci_levels(df)
    macd_colors = ['green' if h > 0 else 'red' for h in df['histogram']]
    mc = mpf.make_marketcolors(up='#2fc71e', down='#ed2f1a', inherit=True)
    s = mpf.make_mpf_style(base_mpl_style=['bmh', 'dark_background'], marketcolors=mc, y_on_right=True)
    add_plots = [
        mpf.make_addplot(df['macd'], panel=1, color='blue', width=1.5, ylabel="MACD"),
        mpf.make_addplot(df['signal'], panel=1, color='orange', width=1.5),
        mpf.make_addplot(df['histogram'], type='bar', color=macd_colors, panel=1)
    ]
    for level, price in fib_levels.items():
        add_plots.append(mpf.make_addplot([price] * len(df), color='yellow', linestyle='--', alpha=0.5, label=f'Fib {level}'))
    fig, axlist = mpf.plot(df[['Open', 'High', 'Low', 'Close']], figratio=(10, 6), type="candle", style=s, tight_layout=True, datetime_format='%H:%M', ylabel="Price ($)", addplot=add_plots, returnfig=True)
    axlist[0].legend(loc='upper left', fontsize=8)
    axlist[0].set_title(f"{symbol} - {title}", fontsize=25, style='italic', fontfamily='sans-serif')
    buf = BytesIO()
    plt.savefig(buf, format='png', bbox_inches='tight')
    buf.seek(0)
    plt.close(fig)
    return buf

# Function to send Telegram message with inline button
async def send_telegram_message(symbol, message, image_buffer, close_price):
    unique_key = f"{symbol}_{message}_{close_price}"
    if last_alert_messages.get(symbol, "") != unique_key:
        keyboard = [[InlineKeyboardButton("Buy", callback_data=f"buy_{symbol}_{close_price}")]]
        reply_markup = InlineKeyboardMarkup(keyboard)
        await telegram_bot.send_message(chat_id=CHAT_ID, text=message, reply_markup=reply_markup)
        await telegram_bot.send_photo(chat_id=CHAT_ID, photo=image_buffer)
        logger.info(f"Sent Telegram message and image for {symbol} with Buy option")
        last_alert_messages[symbol] = unique_key

# Function to place a limit order
def place_limit_order(symbol, side, quantity, price, precision):
    endpoint = "/api/v1/trade/order"
    params = {}
    body = {
        "symbol": symbol,
        "side": side.upper(),
        "type": "LIMIT",
        "size": f"{quantity:.{precision}f}",
        "price": str(price),
        "IOC": False
    }
    response = api_request("POST", endpoint, params, body)
    if response and 'data' in response and response['result']:
        return response['data']
    logger.error(f"Order placement failed: {response}")
    return None

# Function to place a market sell order
def place_market_sell_order(symbol, quantity, precision):
    endpoint = "/api/v1/trade/order"
    params = {}
    body = {
        "symbol": symbol,
        "side": "SELL",
        "type": "MARKET",
        "size": f"{quantity:.{precision}f}"
    }
    response = api_request("POST", endpoint, params, body)
    if response and 'data' in response and response['result']:
        return response['data']
    logger.error(f"Market sell order failed: {response}")
    return None

# Function to cancel an order
def cancel_order(symbol, order_id):
    endpoint = "/api/v1/trade/order"
    params = {"symbol": symbol, "orderId": order_id}
    response = api_request("DELETE", endpoint, params)
    if response and 'result' in response and response['result']:
        logger.info(f"Canceled order {order_id} for {symbol}")
        return True
    logger.error(f"Failed to cancel order {order_id} for {symbol}: {response}")
    return False

# Handle Telegram callback
def handle_telegram_callback(update: Update, context: CallbackContext):
    query = update.callback_query
    query.answer()
    data = query.data.split('_')
    if len(data) < 3:
        context.bot.send_message(chat_id=CHAT_ID, text="Invalid command format.")
        logger.error("Invalid callback data format")
        return
    action, symbol, close_price = data[0], data[1], float(data[2])
    target_usdt = 15.0
    symbol_info = get_symbol_info(symbol)
    if not symbol_info:
        context.bot.send_message(chat_id=CHAT_ID, text=f"Error: Invalid symbol info for {symbol}")
        return
    min_amount = float(symbol_info['minAmount'])
    min_trade_size = float(symbol_info['minTradeSize'])
    base_precision = int(symbol_info['basePrecision'])
    price = close_price
    quantity = target_usdt / price
    if quantity < min_trade_size:
        quantity = min_trade_size
    order_amount = price * quantity
    if order_amount < min_amount:
        context.bot.send_message(chat_id=CHAT_ID, text=f"{symbol}: Order amount ${order_amount:.2f} below minimum ${min_amount}")
        logger.warning(f"{symbol}: Order amount ${order_amount:.2f} below minimum ${min_amount}")
        return
    usdt_balance = get_balance("USDT")
    if usdt_balance < order_amount:
        context.bot.send_message(chat_id=CHAT_ID, text=f"{symbol}: Insufficient USDT (${usdt_balance:.2f} < ${order_amount:.2f})")
        logger.warning(f"{symbol}: Insufficient USDT (${usdt_balance:.2f} < ${order_amount:.2f})")
        return
    if action == "buy":
        buy_result = place_limit_order(symbol, "BUY", quantity, price, base_precision)
        if buy_result:
            order_id = buy_result['orderId']
            logger.info(f"{symbol}: Buy order placed: Order ID {order_id}")
            last_alert_messages[symbol] = "buy"
            context.bot.send_message(chat_id=CHAT_ID, text=f"{symbol}: Buy order placed: Order ID {order_id}")
            sell_price = price * 1.01
            sell_result = place_limit_order(symbol, "SELL", quantity, sell_price, base_precision)
            if sell_result:
                sell_order_id = sell_result['orderId']
                pending_orders[symbol] = sell_order_id
                logger.info(f"{symbol}: Auto sell order placed at ${sell_price:.2f}: Order ID {sell_order_id}")
                context.bot.send_message(chat_id=CHAT_ID, text=f"{symbol}: Auto sell order placed at ${sell_price:.2f}: Order ID {sell_order_id}")
            else:
                context.bot.send_message(chat_id=CHAT_ID, text=f"{symbol}: Failed to place auto sell order")
        else:
            context.bot.send_message(chat_id=CHAT_ID, text=f"{symbol}: Buy order failed")

# Trading bot logic
async def trading_bot(updater):
    target_usdt = 15.0
    logger.info("Fetching USDT pairs...")
    usdt_pairs = get_usdt_pairs()
    if not usdt_pairs:
        logger.error("No USDT pairs found. Stopping bot.")
        return
    logger.info(f"Monitoring {len(usdt_pairs)} USDT pairs: {usdt_pairs[:5]}...")
    symbol_info_dict = {}
    valid_usdt_pairs = []
    for symbol in usdt_pairs[:5]:  # Limit to 5 for testing
        info = get_symbol_info(symbol)
        if info:
            symbol_info_dict[symbol] = info
            valid_usdt_pairs.append(symbol)
        else:
            logger.warning(f"Skipping {symbol} due to invalid symbol info")
    logger.info(f"Valid USDT pairs to monitor: {len(valid_usdt_pairs)}")
    logger.info("Starting Pionex trading bot loop...")
    while True:
        try:
            for symbol in valid_usdt_pairs:
                symbol_info = symbol_info_dict.get(symbol)
                if not symbol_info:
                    continue
                min_amount = float(symbol_info['minAmount'])
                min_trade_size = float(symbol_info['minTradeSize'])
                base_precision = int(symbol_info['basePrecision'])
                historical_data = get_historical_data(symbol, interval_minutes=1, limit=50)
                if historical_data.empty:
                    logger.warning(f"{symbol}: No historical data available")
                    continue
                price = get_price(symbol)
                if price is None:
                    continue
                quantity = target_usdt / price
                if quantity < min_trade_size:
                    quantity = min_trade_size
                order_amount = price * quantity
                if order_amount < min_amount:
                    logger.info(f"{symbol}: Order amount ${order_amount:.2f} below minimum ${min_amount}. Skipping.")
                    continue
                calculate_macd(historical_data)
                cross_over, cross_under = check_macd_signal_crossover(historical_data, symbol)
                holding = last_alert_messages.get(symbol) == "buy"
                if cross_over and not holding:
                    message = f"#Long #{symbol} - MACD Cross Over\nPrice: ${price:.2f}"
                    image_buffer = plot_candles(historical_data, symbol, "MACD Cross Over")
                    await send_telegram_message(symbol, message, image_buffer, price)
                elif cross_under and holding:
                    if symbol in pending_orders:
                        order_id = pending_orders[symbol]
                        if cancel_order(symbol, order_id):
                            del pending_orders[symbol]
                    logger.info(f"{symbol}: MACD Cross Under! Selling {quantity:.8f} at market price")
                    sell_result = place_market_sell_order(symbol, quantity, base_precision)
                    if sell_result:
                        logger.info(f"{symbol}: Market sell order placed: Order ID {sell_result['orderId']}")
                        last_alert_messages[symbol] = "sold"
                        await telegram_bot.send_message(chat_id=CHAT_ID, text=f"{symbol}: Market sell order placed: Order ID {sell_result['orderId']}")
                    else:
                        await telegram_bot.send_message(chat_id=CHAT_ID, text=f"{symbol}: Market sell order failed")
                else:
                    logger.info(f"{symbol}: Current price: ${price} - No action (Holding: {holding})")
            await asyncio.sleep(10)
        except Exception as e:
            logger.error(f"Error in bot loop: {e}")
            await asyncio.sleep(10)

# Main function
def main():
    logger.info("Starting main function...")
    updater = Updater(TELEGRAM_TOKEN, use_context=True)
    dp = updater.dispatcher
    dp.add_handler(CallbackQueryHandler(handle_telegram_callback, pattern='^buy_'))
    logger.info("Starting trading bot...")
    asyncio.ensure_future(trading_bot(updater))
    logger.info("Starting Telegram polling...")
    updater.start_polling()
    updater.idle()

if __name__ == "__main__":
    logger.info("Script starting...")
    main()
