import requests
import time
import hmac
import hashlib
from urllib.parse import urlencode
import json
import pandas as pd
import matplotlib.pyplot as plt
import mplfinance as mpf
from io import BytesIO
import asyncio
import nest_asyncio
from telegram import Bot
import ta
import config  # Import config.py for API credentials

# API setup
BASE_URL = "https://api.pionex.com"
API_KEY = config.API_KEY
SECRET_KEY = config.SECRET_KEY
TELEGRAM_TOKEN = config.TELEGRAM_TOKEN_RSI  # Add to config.py
CHAT_ID = config.CHAT_ID  # Add to config.py

# Telegram setup
telegram_bot = Bot(token=TELEGRAM_TOKEN)
nest_asyncio.apply()

# Function to generate HMAC SHA256 signature
def generate_signature(method, path, params, body=None):
    timestamp = str(int(time.time() * 1000))
    query_params = params.copy()
    query_params['timestamp'] = timestamp
    sorted_params = urlencode(sorted(query_params.items()))
    path_url = f"{path}?{sorted_params}"
    string_to_sign = f"{method}{path_url}"
    if body:
        string_to_sign += json.dumps(body, separators=(',', ':'))
    signature = hmac.new(
        SECRET_KEY.encode('utf-8'),
        string_to_sign.encode('utf-8'),
        hashlib.sha256
    ).hexdigest()
    return signature, timestamp

# Function to make authenticated API requests
def api_request(method, endpoint, params=None, body=None):
    if params is None:
        params = {}
    signature, timestamp = generate_signature(method, endpoint, params, body)
    params['timestamp'] = timestamp
    url = f"{BASE_URL}{endpoint}"
    headers = {
        "PIONEX-KEY": API_KEY,
        "PIONEX-SIGNATURE": signature,
        "Content-Type": "application/json"
    }
    try:
        if method == "GET":
            response = requests.get(url, headers=headers, params=params)
        elif method == "POST":
            response = requests.post(url, headers=headers, params=params, data=json.dumps(body, separators=(',', ':')))
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        print(f"API request failed: {e}")
        return None

# Function to get all USDT pairs
def get_usdt_pairs():
    endpoint = "/api/v1/common/symbols"
    data = api_request("GET", endpoint)
    if data and 'data' in data and 'symbols' in data['data']:
        usdt_pairs = [s['symbol'] for s in data['data']['symbols'] if s['symbol'].endswith('_USDT') and s['enable']]
        return usdt_pairs
    print("Error: Failed to fetch USDT pairs")
    return []

# Function to get symbol info with error handling
def get_symbol_info(symbol):
    endpoint = "/api/v1/common/symbols"
    params = {"symbols": symbol}
    data = api_request("GET", endpoint, params)
    if data and 'data' in data and 'symbols' in data['data'] and data['data']['symbols']:
        return data['data']['symbols'][0]
    print(f"Error: No symbol info returned for {symbol} - Response: {data}")
    return None

# Function to get account balance
def get_balance(currency="USDT"):
    endpoint = "/api/v1/account/balances"
    data = api_request("GET", endpoint)
    if data and 'data' in data and 'balances' in data['data']:
        for balance in data['data']['balances']:
            if balance['coin'] == currency:
                return float(balance['free'])
    print(f"Error: Failed to fetch balance for {currency}")
    return 0.0

# Function to get current price
def get_price(symbol):
    endpoint = "/api/v1/market/depth"
    params = {"symbol": symbol}
    data = api_request("GET", endpoint, params)
    if data and 'data' in data and 'bids' in data['data'] and data['data']['bids']:
        bid = float(data['data']['bids'][0][0])
        ask = float(data['data']['asks'][0][0])
        return (bid + ask) / 2
    print(f"Error: Failed to fetch price data for {symbol}")
    return None

# Simulate historical OHLCV data with more volatility
def get_historical_data(symbol, interval_minutes=1, limit=50):
    data = []
    base_price = get_price(symbol)
    if not base_price:
        return pd.DataFrame()
    for i in range(limit):
        price = base_price * (1 + 0.005 * (i % 2 - 0.5))  # Alternates Â±0.5%
        timestamp = int(time.time() * 1000) - (i * interval_minutes * 60 * 1000)
        open_price = price * (1 - 0.002)
        high_price = price * (1 + 0.003)
        low_price = price * (1 - 0.004)
        close_price = price
        volume = 100  # Placeholder
        data.append([timestamp, open_price, high_price, low_price, close_price, volume])
        time.sleep(0.1)  # Reduced delay for testing
    df = pd.DataFrame(data, columns=['timestamp', 'open', 'high', 'low', 'close', 'volume'])
    df['timestamp'] = pd.to_datetime(df['timestamp'], unit='ms')
    df.set_index('timestamp', inplace=True)
    df.columns = ['Open', 'High', 'Low', 'Close', 'Volume']
    return df

# MACD calculation
def calculate_macd(df):
    macd = ta.trend.MACD(df['Close'])
    df['macd'] = macd.macd()
    df['signal'] = macd.macd_signal()
    df['histogram'] = macd.macd_diff()

# Check MACD crossover
def check_macd_signal_crossover(df, symbol):
    if len(df) < 3:
        return False, False
    # Force a crossover for testing on BTC_USDT (remove after testing)
    if symbol == "BTC_USDT" and not hasattr(check_macd_signal_crossover, 'tested'):
        check_macd_signal_crossover.tested = True
        return True, False  # Simulate a buy signal once
    macd_prev = df['macd'].iloc[-2]
    macd_curr = df['macd'].iloc[-1]
    signal_prev = df['signal'].iloc[-2]
    signal_curr = df['signal'].iloc[-1]
    cross_over = macd_prev < signal_prev and macd_curr > signal_curr
    cross_under = macd_prev > signal_prev and macd_curr < signal_curr
    return cross_over, cross_under

# Fibonacci levels
def calculate_fibonacci_levels(df):
    high = df['High'].max()
    low = df['Low'].min()
    diff = high - low
    levels = {
        '0.0%': high,
        '23.6%': high - (0.236 * diff),
        '38.2%': high - (0.382 * diff),
        '50.0%': high - (0.5 * diff),
        '61.8%': high - (0.618 * diff),
        '100.0%': low
    }
    return levels

# Plot candlestick chart with MACD and Fibonacci
def plot_candles(df, symbol, title):
    calculate_macd(df)
    fib_levels = calculate_fibonacci_levels(df)

    macd_colors = ['green' if h > 0 else 'red' for h in df['histogram']]
    mc = mpf.make_marketcolors(up='#2fc71e', down='#ed2f1a', inherit=True)
    s = mpf.make_mpf_style(base_mpl_style=['bmh', 'dark_background'], marketcolors=mc, y_on_right=True)

    add_plots = [
        mpf.make_addplot(df['macd'], panel=1, color='blue', width=1.5, ylabel="MACD"),
        mpf.make_addplot(df['signal'], panel=1, color='orange', width=1.5),
        mpf.make_addplot(df['histogram'], type='bar', color=macd_colors, panel=1)
    ]

    for level, price in fib_levels.items():
        add_plots.append(
            mpf.make_addplot(
                [price] * len(df),
                color='yellow',
                linestyle='--',
                alpha=0.5,
                label=f'Fib {level}'
            )
        )

    fig, axlist = mpf.plot(
        df[['Open', 'High', 'Low', 'Close']],
        figratio=(10, 6),
        type="candle",
        style=s,
        tight_layout=True,
        datetime_format='%H:%M',
        ylabel="Price ($)",
        addplot=add_plots,
        returnfig=True
    )

    axlist[0].legend(loc='upper left', fontsize=8)
    axlist[0].set_title(f"{symbol} - {title}", fontsize=25, style='italic', fontfamily='sans-serif')

    buf = BytesIO()
    plt.savefig(buf, format='png', bbox_inches='tight')
    buf.seek(0)
    plt.close(fig)
    return buf

# Send Telegram message with chart
async def send_telegram_message(symbol, message, image_buffer):
    try:
        await telegram_bot.send_message(chat_id=CHAT_ID, text=message)
        await telegram_bot.send_photo(chat_id=CHAT_ID, photo=image_buffer)
        print(f"Sent Telegram message and image for {symbol}")
    except Exception as e:
        print(f"Failed to send Telegram message for {symbol}: {e}")

# Function to place an order
def place_order(symbol, side, quantity, price, precision):
    endpoint = "/api/v1/trade/order"
    params = {}
    body = {
        "symbol": symbol,
        "side": side.upper(),
        "type": "LIMIT",
        "size": f"{quantity:.{precision}f}",
        "price": str(price),
        "IOC": False
    }
    response = api_request("POST", endpoint, params, body)
    if response and 'data' in response and response['result']:
        return response['data']
    else:
        print(f"Order placement failed: {response}")
        return None

# Trading bot logic for all USDT pairs
async def trading_bot():
    target_usdt = 15.0  # Target $15 worth per trade
    holdings = {}  # Track holdings for each symbol

    # Get all USDT pairs
    usdt_pairs = get_usdt_pairs()
    if not usdt_pairs:
        print("No USDT pairs found. Stopping bot.")
        return
    print(f"Monitoring {len(usdt_pairs)} USDT pairs: {usdt_pairs[:5]}...")

    # Get symbol info for all pairs, filtering out invalid ones
    symbol_info_dict = {}
    valid_usdt_pairs = []
    for symbol in usdt_pairs[:5]:  # Limit to 5 pairs for testing
        info = get_symbol_info(symbol)
        if info:
            symbol_info_dict[symbol] = info
            valid_usdt_pairs.append(symbol)
        else:
            print(f"Skipping {symbol} due to invalid symbol info")

    print(f"Valid USDT pairs to monitor: {len(valid_usdt_pairs)}")

    print("Starting Pionex trading bot...")
    while True:
        try:
            for symbol in valid_usdt_pairs:
                symbol_info = symbol_info_dict.get(symbol)
                if not symbol_info:
                    continue

                min_amount = float(symbol_info['minAmount'])
                min_trade_size = float(symbol_info['minTradeSize No symbol info returned'])
                base_precision = int(symbol_info['basePrecision'])

                # Fetch historical data
                historical_data = get_historical_data(symbol, interval_minutes=1, limit=50)
                if historical_data.empty:
                    print(f"{symbol}: No historical data available")
                    continue

                price = get_price(symbol)
                if price is None:
                    continue

                # Calculate quantity for $15 worth
                quantity = target_usdt / price
                if quantity < min_trade_size:
                    quantity = min_trade_size

                order_amount = price * quantity
                if order_amount < min_amount:
                    print(f"{symbol}: Order amount ${order_amount:.2f} below minimum ${min_amount}. Skipping trade.")
                    continue

                # MACD strategy
                calculate_macd(historical_data)
                cross_over, cross_under = check_macd_signal_crossover(historical_data, symbol)
                holding = holdings.get(symbol, False)

                # Send Telegram message and image on crossover, regardless of order
                if cross_over and not holding:
                    message = f"#Long #{symbol} - MACD Cross Over"
                    image_buffer = plot_candles(historical_data, symbol, "MACD Cross Over")
                    await send_telegram_message(symbol, message, image_buffer)

                    usdt_balance = get_balance("USDT")
                    if usdt_balance < order_amount:
                        print(f"{symbol}: Insufficient USDT (${usdt_balance:.2f} < ${order_amount:.2f}). Skipping trade.")
                        continue

                    print(f"{symbol}: MACD Cross Over! Buying {quantity:.8f} at ${price}")
                    result = place_order(symbol, "BUY", quantity, price, base_precision)
                    if result:
                        print(f"{symbol}: Buy order placed: Order ID {result['orderId']}")
                        holdings[symbol] = True
                    else:
                        print(f"{symbol}: Buy order failed, but signal sent")

                elif cross_under and holding:
                    message = f"#Short #{symbol} - MACD Cross Under"
                    image_buffer = plot_candles(historical_data, symbol, "MACD Cross Under")
                    await send_telegram_message(symbol, message, image_buffer)

                    print(f"{symbol}: MACD Cross Under! Selling {quantity:.8f} at ${price}")
                    result = place_order(symbol, "SELL", quantity, price, base_precision)
                    if result:
                        print(f"{symbol}: Sell order placed: Order ID {result['orderId']}")
                        holdings[symbol] = False
                    else:
                        print(f"{symbol}: Sell order failed, but signal sent")

                else:
                    print(f"{symbol}: Current price: ${price} - No action (Holding: {holding})")

            await asyncio.sleep(10)  # Reduced sleep for testing
        except Exception as e:
            print(f"Error in bot loop: {e}")
            await asyncio.sleep(10)

# Run the bot
if __name__ == "__main__":
    asyncio.run(trading_bot())